{% comment %}
Weather Widget Component
Uses Open-Meteo API for free weather data without API key
{% endcomment %}

{% if site.weather.enabled %}
<div class="weather-widget" id="weather-widget">
    <div class="weather-header">
        <h3 class="weather-title">
            <span class="weather-icon">üå§Ô∏è</span>
            Poƒças√≠
        </h3>
        <select class="weather-city-select" id="weather-city-select">
            {% for city in site.weather.cities %}
            <option value="{{ city.latitude }},{{ city.longitude }}" {% if city.name == site.weather.default_location.name %}selected{% endif %}>
                {{ city.name }}
            </option>
            {% endfor %}
        </select>
    </div>
    
    <div class="weather-content" id="weather-content">
        <div class="weather-loading">
            <div class="weather-spinner"></div>
            <span>Naƒç√≠t√°n√≠...</span>
        </div>
    </div>
    
    <div class="weather-error" id="weather-error" style="display: none;">
        <span class="weather-error-icon">‚ö†Ô∏è</span>
        <span class="weather-error-text">Nepoda≈ôilo se naƒç√≠st poƒças√≠</span>
        <button class="weather-retry-btn" onclick="loadWeatherData()">Zkusit znovu</button>
    </div>
    
    <div class="weather-updated" id="weather-updated" style="display: none;">
        <small>Aktualizov√°no: <span id="weather-last-update"></span></small>
    </div>
</div>

<script>
// Weather Widget Configuration
const WEATHER_CONFIG = {
    apiUrl: "{{ site.weather.api_url }}",
    defaultLocation: {
        name: "{{ site.weather.default_location.name }}",
        latitude: {{ site.weather.default_location.latitude }},
        longitude: {{ site.weather.default_location.longitude }}
    },
    updateInterval: {{ site.weather.update_interval }},
    cacheDuration: {{ site.weather.cache_duration }}
};

// Weather icons mapping
const WEATHER_ICONS = {
    0: '‚òÄÔ∏è',   // Clear sky
    1: 'üå§Ô∏è',   // Mainly clear
    2: '‚õÖ',   // Partly cloudy
    3: '‚òÅÔ∏è',   // Overcast
    45: 'üå´Ô∏è',  // Fog
    48: 'üå´Ô∏è',  // Depositing rime fog
    51: 'üå¶Ô∏è',  // Light drizzle
    53: 'üå¶Ô∏è',  // Moderate drizzle
    55: 'üåßÔ∏è',  // Dense drizzle
    56: 'üåßÔ∏è',  // Light freezing drizzle
    57: 'üåßÔ∏è',  // Dense freezing drizzle
    61: 'üåßÔ∏è',  // Slight rain
    63: 'üåßÔ∏è',  // Moderate rain
    65: 'üåßÔ∏è',  // Heavy rain
    66: 'üåßÔ∏è',  // Light freezing rain
    67: 'üåßÔ∏è',  // Heavy freezing rain
    71: 'üå®Ô∏è',  // Slight snow fall
    73: 'üå®Ô∏è',  // Moderate snow fall
    75: '‚ùÑÔ∏è',   // Heavy snow fall
    77: '‚ùÑÔ∏è',   // Snow grains
    80: 'üå¶Ô∏è',  // Slight rain showers
    81: 'üåßÔ∏è',  // Moderate rain showers
    82: 'üåßÔ∏è',  // Violent rain showers
    85: 'üå®Ô∏è',  // Slight snow showers
    86: '‚ùÑÔ∏è',   // Heavy snow showers
    95: '‚õàÔ∏è',   // Thunderstorm
    96: '‚õàÔ∏è',   // Thunderstorm with slight hail
    99: '‚õàÔ∏è'    // Thunderstorm with heavy hail
};

// Weather descriptions in Czech
const WEATHER_DESCRIPTIONS = {
    0: 'Jasno',
    1: 'P≈ôev√°≈ænƒõ jasno',
    2: 'ƒå√°steƒçnƒõ oblaƒçno',
    3: 'Zata≈æeno',
    45: 'Mlha',
    48: 'N√°mraza',
    51: 'Slab√© mrholen√≠',
    53: 'M√≠rn√© mrholen√≠',
    55: 'Hust√© mrholen√≠',
    56: 'Slab√© mrznouc√≠ mrholen√≠',
    57: 'Hust√© mrznouc√≠ mrholen√≠',
    61: 'Slab√Ω d√©≈°≈•',
    63: 'M√≠rn√Ω d√©≈°≈•',
    65: 'Siln√Ω d√©≈°≈•',
    66: 'Slab√Ω mrznouc√≠ d√©≈°≈•',
    67: 'Siln√Ω mrznouc√≠ d√©≈°≈•',
    71: 'Slab√© snƒõ≈æen√≠',
    73: 'M√≠rn√© snƒõ≈æen√≠',
    75: 'Siln√© snƒõ≈æen√≠',
    77: 'Snƒõhov√© zrno',
    80: 'Slab√© p≈ôeh√°≈àky',
    81: 'M√≠rn√© p≈ôeh√°≈àky',
    82: 'Siln√© p≈ôeh√°≈àky',
    85: 'Slab√© snƒõhov√© p≈ôeh√°≈àky',
    86: 'Siln√© snƒõhov√© p≈ôeh√°≈àky',
    95: 'Bou≈ôka',
    96: 'Bou≈ôka s krupobit√≠m',
    99: 'Bou≈ôka se siln√Ωm krupobit√≠m'
};

// Activity recommendations based on weather conditions
function getActivityRecommendation(weatherCode, temperature, humidity, windSpeed) {
    let score = 0;
    let activity = '';
    let reason = '';
    
    // Temperature scoring (ideal for programming: 18-24¬∞C)
    if (temperature >= 18 && temperature <= 24) {
        score += 2;
    } else if (temperature < 10 || temperature > 30) {
        score -= 2;
    } else {
        score -= 1;
    }
    
    // Weather condition scoring
    const badWeatherCodes = [61, 63, 65, 66, 67, 71, 73, 75, 80, 81, 82, 85, 86, 95, 96, 99];
    const goodWeatherCodes = [0, 1];
    const okWeatherCodes = [2, 3, 45, 48, 51, 53, 55, 56, 57, 77];
    
    if (badWeatherCodes.includes(weatherCode)) {
        score += 2; // Bad weather = good for programming
    } else if (goodWeatherCodes.includes(weatherCode) && temperature >= 15 && temperature <= 28) {
        score -= 2; // Beautiful weather = go outside
    } else if (okWeatherCodes.includes(weatherCode)) {
        score += 1;
    }
    
    // Wind factor
    if (windSpeed > 25) {
        score += 1; // Windy = stay inside
    }
    
    // Humidity factor
    if (humidity > 80) {
        score += 1; // High humidity = stay inside
    } else if (humidity < 40) {
        score -= 1; // Low humidity = nice outside
    }
    
    // Determine recommendation
    if (score >= 2) {
        activity = 'üíª Ide√°ln√≠ pro programov√°n√≠!';
        const reasons = [];
        if (temperature >= 18 && temperature <= 24) reasons.push('p≈ô√≠jemn√° teplota');
        if (badWeatherCodes.includes(weatherCode)) reasons.push('≈°patn√© poƒças√≠ venku');
        if (humidity > 80) reasons.push('vysok√° vlhkost');
        if (windSpeed > 25) reasons.push('siln√Ω v√≠tr');
        
        reason = reasons.length > 0 ? `${reasons.join(', ')}` : 'podm√≠nky p≈ô√≠zniv√© pro pr√°ci u poƒç√≠taƒçe';
    } else if (score <= -1) {
        activity = 'üåø ƒåas j√≠t ven!';
        const reasons = [];
        if (goodWeatherCodes.includes(weatherCode)) reasons.push('kr√°sn√© poƒças√≠');
        if (temperature >= 15 && temperature <= 28) reasons.push('p≈ô√≠jemn√° teplota');
        if (humidity < 40) reasons.push('n√≠zk√° vlhkost');
        
        reason = reasons.length > 0 ? `${reasons.join(', ')}` : 'p≈ô√≠zniv√© podm√≠nky pro venkovn√≠ aktivity';
    } else {
        activity = '‚öñÔ∏è Neutr√°ln√≠ podm√≠nky';
        reason = 'ani v√Ωraznƒõ pro coding, ani pro venkovn√≠ aktivity';
    }
    
    return { activity, reason };
}

// Initialize weather widget on page load
document.addEventListener('DOMContentLoaded', function() {
    initWeatherWidget();
});

function initWeatherWidget() {
    // Set up city selector change event
    const citySelect = document.getElementById('weather-city-select');
    if (citySelect) {
        citySelect.addEventListener('change', function() {
            const [lat, lon] = this.value.split(',');
            const cityName = this.options[this.selectedIndex].text;
            
            // Save user selection to localStorage
            savePreferredCity(cityName, parseFloat(lat), parseFloat(lon));
            loadWeatherData(parseFloat(lat), parseFloat(lon), cityName);
        });
    }
    
    // Smart city detection or load from localStorage
    initializeLocation();
    
    // Set up automatic updates
    setInterval(() => {
        const location = getStoredLocation();
        if (location) {
            loadWeatherData(location.latitude, location.longitude, location.name);
        } else {
            loadWeatherData();
        }
    }, WEATHER_CONFIG.updateInterval);
}

function initializeLocation() {
    const storedLocation = getStoredLocation();
    
    if (storedLocation) {
        // User has visited before, use stored location
        console.log('Using stored location:', storedLocation.name);
        setSelectedCity(storedLocation.name, storedLocation.latitude, storedLocation.longitude);
        loadWeatherData(storedLocation.latitude, storedLocation.longitude, storedLocation.name);
    } else {
        // First visit, try to detect location
        console.log('First visit - attempting location detection');
        detectUserLocation();
    }
}

async function detectUserLocation() {
    try {
        // Try GeoIP detection using ipapi.co (free, no API key needed)
        const response = await fetch('https://ipapi.co/json/');
        
        if (!response.ok) {
            throw new Error('GeoIP service unavailable');
        }
        
        const data = await response.json();
        
        // Check if we got a city in Czech Republic or Slovakia (our supported regions)
        if (data.country_code === 'CZ' || data.country_code === 'SK') {
            const detectedCity = findNearestSupportedCity(data.latitude, data.longitude, data.city);
            
            if (detectedCity) {
                console.log('Detected location:', detectedCity.name);
                savePreferredCity(detectedCity.name, detectedCity.latitude, detectedCity.longitude);
                setSelectedCity(detectedCity.name, detectedCity.latitude, detectedCity.longitude);
                loadWeatherData(detectedCity.latitude, detectedCity.longitude, detectedCity.name);
                return;
            }
        }
        
        // Fallback to Prague if detection failed or unsupported region
        throw new Error('Unsupported region or city not found');
        
    } catch (error) {
        console.log('Location detection failed, using Prague as default:', error.message);
        // Fallback to Prague
        const prague = { name: 'Praha', latitude: 50.0755, longitude: 14.4378 };
        savePreferredCity(prague.name, prague.latitude, prague.longitude);
        setSelectedCity(prague.name, prague.latitude, prague.longitude);
        loadWeatherData(prague.latitude, prague.longitude, prague.name);
    }
}

function findNearestSupportedCity(lat, lon, cityName) {
    // Get cities from the config
    const cities = {{ site.weather.cities | jsonify }};
    
    // First try exact city name match
    const exactMatch = cities.find(city => 
        city.name.toLowerCase() === cityName.toLowerCase() ||
        city.name.toLowerCase().includes(cityName.toLowerCase()) ||
        cityName.toLowerCase().includes(city.name.toLowerCase())
    );
    
    if (exactMatch) {
        return exactMatch;
    }
    
    // Find nearest city by distance
    let nearestCity = cities[0];
    let minDistance = getDistance(lat, lon, cities[0].latitude, cities[0].longitude);
    
    for (let i = 1; i < cities.length; i++) {
        const distance = getDistance(lat, lon, cities[i].latitude, cities[i].longitude);
        if (distance < minDistance) {
            minDistance = distance;
            nearestCity = cities[i];
        }
    }
    
    // Only return if reasonably close (within 100km)
    return minDistance <= 100 ? nearestCity : null;
}

function getDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth's radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function savePreferredCity(name, latitude, longitude) {
    const location = { name, latitude, longitude, timestamp: new Date().getTime() };
    try {
        localStorage.setItem('weather_preferred_city', JSON.stringify(location));
    } catch (error) {
        console.error('Failed to save preferred city:', error);
    }
}

function getStoredLocation() {
    try {
        const stored = localStorage.getItem('weather_preferred_city');
        if (!stored) return null;
        
        const location = JSON.parse(stored);
        // Check if stored location is recent (within 30 days)
        const thirtyDaysAgo = new Date().getTime() - (30 * 24 * 60 * 60 * 1000);
        
        if (location.timestamp > thirtyDaysAgo) {
            return location;
        } else {
            // Old preference, remove it
            localStorage.removeItem('weather_preferred_city');
            return null;
        }
    } catch (error) {
        console.error('Failed to get stored location:', error);
        return null;
    }
}

function setSelectedCity(cityName, latitude, longitude) {
    const citySelect = document.getElementById('weather-city-select');
    if (citySelect) {
        const targetValue = `${latitude},${longitude}`;
        const option = Array.from(citySelect.options).find(opt => opt.value === targetValue);
        if (option) {
            citySelect.value = targetValue;
        }
    }
}

async function loadWeatherData(lat, lon, cityName) {
    const latitude = lat || WEATHER_CONFIG.defaultLocation.latitude;
    const longitude = lon || WEATHER_CONFIG.defaultLocation.longitude;
    const city = cityName || WEATHER_CONFIG.defaultLocation.name;
    
    const cacheKey = `weather_${latitude}_${longitude}`;
    const cachedData = getCachedWeatherData(cacheKey);
    
    if (cachedData) {
        displayWeatherData(cachedData, city);
        return;
    }
    
    showWeatherLoading();
    
    try {
        const url = `${WEATHER_CONFIG.apiUrl}/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m&hourly=temperature_2m,weather_code&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=Europe/Prague`;
        
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        
        // Cache the data
        cacheWeatherData(cacheKey, data);
        
        displayWeatherData(data, city);
        hideWeatherError();
        
    } catch (error) {
        console.error('Weather API error:', error);
        showWeatherError();
    }
}

function getCachedWeatherData(cacheKey) {
    try {
        const cached = localStorage.getItem(cacheKey);
        if (!cached) return null;
        
        const { data, timestamp } = JSON.parse(cached);
        const now = new Date().getTime();
        
        // Check if cache is still valid
        if (now - timestamp < WEATHER_CONFIG.cacheDuration) {
            return data;
        } else {
            localStorage.removeItem(cacheKey);
            return null;
        }
    } catch (error) {
        console.error('Cache error:', error);
        return null;
    }
}

function cacheWeatherData(cacheKey, data) {
    try {
        const cacheData = {
            data: data,
            timestamp: new Date().getTime()
        };
        localStorage.setItem(cacheKey, JSON.stringify(cacheData));
    } catch (error) {
        console.error('Cache save error:', error);
    }
}

function displayWeatherData(data, cityName) {
    const contentDiv = document.getElementById('weather-content');
    const current = data.current;
    const daily = data.daily;
    
    const currentIcon = WEATHER_ICONS[current.weather_code] || 'üå§Ô∏è';
    const currentDescription = WEATHER_DESCRIPTIONS[current.weather_code] || 'Nezn√°m√© poƒças√≠';
    
    // Get activity recommendation
    const recommendation = getActivityRecommendation(
        current.weather_code,
        current.temperature_2m,
        current.relative_humidity_2m,
        current.wind_speed_10m
    );
    
    const html = `
        <div class="weather-current">
            <div class="weather-main">
                <span class="weather-current-icon">${currentIcon}</span>
                <div class="weather-temp-info">
                    <span class="weather-temperature">${Math.round(current.temperature_2m)}¬∞C</span>
                    <span class="weather-description">${currentDescription}</span>
                </div>
            </div>
            <div class="weather-details">
                <div class="weather-detail">
                    <span class="weather-detail-label">Vlhkost:</span>
                    <span class="weather-detail-value">${current.relative_humidity_2m}%</span>
                </div>
                <div class="weather-detail">
                    <span class="weather-detail-label">V√≠tr:</span>
                    <span class="weather-detail-value">${Math.round(current.wind_speed_10m)} km/h</span>
                </div>
            </div>
        </div>
        
        <div class="weather-recommendation">
            <div class="weather-activity-tip">
                <span class="weather-activity-icon">${recommendation.activity.split(' ')[0]}</span>
                <div class="weather-activity-text">
                    <strong>${recommendation.activity.substring(2)}</strong>
                    <small>${recommendation.reason}</small>
                </div>
            </div>
        </div>
        
        <div class="weather-forecast">
            <h4 class="weather-forecast-title">P≈ôedpovƒõƒè na 3 dny</h4>
            <div class="weather-forecast-days">
                ${daily.time.slice(1, 4).map((date, index) => {
                    const dayIndex = index + 1;
                    const dayName = getDayName(new Date(date));
                    const icon = WEATHER_ICONS[daily.weather_code[dayIndex]] || 'üå§Ô∏è';
                    const maxTemp = Math.round(daily.temperature_2m_max[dayIndex]);
                    const minTemp = Math.round(daily.temperature_2m_min[dayIndex]);
                    
                    return `
                        <div class="weather-forecast-day">
                            <span class="weather-forecast-day-name">${dayName}</span>
                            <span class="weather-forecast-icon">${icon}</span>
                            <div class="weather-forecast-temps">
                                <span class="weather-forecast-max">${maxTemp}¬∞</span>
                                <span class="weather-forecast-min">${minTemp}¬∞</span>
                            </div>
                        </div>
                    `;
                }).join('')}
            </div>
        </div>
    `;
    
    contentDiv.innerHTML = html;
    
    // Update last updated time
    updateLastUpdateTime();
    
    hideWeatherLoading();
}

function getDayName(date) {
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    if (date.toDateString() === tomorrow.toDateString()) {
        return 'Z√≠tra';
    }
    
    const dayNames = ['Ne', 'Po', '√öt', 'St', 'ƒåt', 'P√°', 'So'];
    return dayNames[date.getDay()];
}

function updateLastUpdateTime() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('cs-CZ', { 
        hour: '2-digit', 
        minute: '2-digit' 
    });
    
    const updateElement = document.getElementById('weather-last-update');
    const updatedElement = document.getElementById('weather-updated');
    
    if (updateElement && updatedElement) {
        updateElement.textContent = timeString;
        updatedElement.style.display = 'block';
    }
}

function showWeatherLoading() {
    const contentDiv = document.getElementById('weather-content');
    const errorDiv = document.getElementById('weather-error');
    const updatedDiv = document.getElementById('weather-updated');
    
    if (contentDiv) {
        contentDiv.innerHTML = `
            <div class="weather-loading">
                <div class="weather-spinner"></div>
                <span>Naƒç√≠t√°n√≠...</span>
            </div>
        `;
    }
    if (errorDiv) errorDiv.style.display = 'none';
    if (updatedDiv) updatedDiv.style.display = 'none';
}

function hideWeatherLoading() {
    // Loading is hidden when content is displayed
}

function showWeatherError() {
    const errorDiv = document.getElementById('weather-error');
    const contentDiv = document.getElementById('weather-content');
    const updatedDiv = document.getElementById('weather-updated');
    
    if (errorDiv) errorDiv.style.display = 'block';
    if (contentDiv) contentDiv.style.display = 'none';
    if (updatedDiv) updatedDiv.style.display = 'none';
}

function hideWeatherError() {
    const errorDiv = document.getElementById('weather-error');
    const contentDiv = document.getElementById('weather-content');
    
    if (errorDiv) errorDiv.style.display = 'none';
    if (contentDiv) contentDiv.style.display = 'block';
}
</script>
{% endif %}